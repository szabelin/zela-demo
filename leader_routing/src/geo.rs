//! Validator-to-region lookup using precomputed PHF map.
//!
//! Uses a compile-time PHF (Perfect Hash Function) map generated by build.rs
//! from data/leader_geo.json. Provides O(1) lookup for validator -> region.
//!
//! # Fallback Behavior
//!
//! If a validator is not found in the map, returns `Region::Unknown`.
//! Unknown validators route to Frankfurt as the default because:
//! - ~38% of Solana validators are located in Europe
//! - Frankfurt's central EU position minimizes worst-case latency
//! - It's a common hosting location for blockchain infrastructure
//!
//! Note: If validator geographic distribution changes significantly,
//! the default region can be updated by modifying `Region::DEFAULT` in region.rs.
//! Monitor distribution via `precompute_geo.py` output logs which show region counts.

use crate::region::Region;

// Include the generated PHF map
include!(concat!(env!("OUT_DIR"), "/phf_geo.rs"));

/// Returns true if this module has no geo data (empty PHF map).
///
/// Used by tests to check if real geo data is loaded.
pub fn is_stub() -> bool {
    VALIDATOR_TO_REGION.is_empty()
}

/// Get the region for a validator pubkey.
///
/// Performs O(1) PHF lookup. Returns Region::Unknown if the validator
/// is not in the precomputed geo data.
///
/// # Arguments
/// * `pubkey` - The 32-byte validator pubkey (type-safe: `[u8; 32]` ensures
///   exactly 32 bytes at compile time, no runtime validation needed)
///
/// # Returns
/// The region where the validator is located, or Unknown if not found.
pub fn get_region(pubkey: &[u8; 32]) -> Region {
    match VALIDATOR_TO_REGION.get(pubkey) {
        Some(&region_code) => Region::from(region_code),
        None => Region::Unknown,
    }
}

/// Get the geographic label for a validator.
///
/// Returns a human-readable location string like "Europe/Frankfurt".
/// For unknown validators, returns "UNKNOWN".
pub fn get_geo_label(pubkey: &[u8; 32]) -> &'static str {
    get_region(pubkey).geo_label()
}

/// Number of validators with known geo data.
///
/// Returns 0 when using stub data (no leader_geo.json).
pub fn validator_count() -> usize {
    VALIDATOR_TO_REGION.len()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_unknown_pubkey_returns_unknown() {
        // Pubkeys not in the geo map return Unknown
        let pubkey = [0u8; 32];
        assert_eq!(get_region(&pubkey), Region::Unknown);
    }

    #[test]
    fn test_unknown_geo_label() {
        // Unknown validators have UNKNOWN geo label
        let pubkey = [0u8; 32];
        assert_eq!(get_geo_label(&pubkey), "UNKNOWN");
    }

    #[test]
    fn test_is_stub_function() {
        // is_stub() returns true when PHF map is empty (stub mode)
        // Returns false when real geo data is loaded
        // Note: In tests without data, this will be true
        let _is_stub = is_stub();
        // Just verify function works, actual value depends on build
    }

    #[test]
    fn test_different_unknown_pubkeys() {
        // All unknown pubkeys should return Unknown region
        let pubkey1 = [0u8; 32];
        let pubkey2 = [0xff; 32];
        let mut pubkey3 = [0u8; 32];
        pubkey3[0] = 0x12;
        pubkey3[31] = 0x34;

        // These are not in any geo map, so return Unknown
        assert_eq!(get_region(&pubkey1), Region::Unknown);
        assert_eq!(get_region(&pubkey2), Region::Unknown);
        assert_eq!(get_region(&pubkey3), Region::Unknown);
    }

    #[test]
    fn test_unknown_routes_to_frankfurt() {
        // Unknown region routes to Frankfurt via routing_destination
        let pubkey = [0u8; 32];
        let region = get_region(&pubkey);
        assert_eq!(region.routing_destination(), Region::Frankfurt);
    }

    #[test]
    fn test_region_code_conversion() {
        // Verify all region codes (0-4) convert correctly via Region::from
        // This ensures PHF values are handled properly
        assert_eq!(Region::from(0u8), Region::Frankfurt);
        assert_eq!(Region::from(1u8), Region::Dubai);
        assert_eq!(Region::from(2u8), Region::NewYork);
        assert_eq!(Region::from(3u8), Region::Tokyo);
        assert_eq!(Region::from(4u8), Region::Unknown);
        // Any other u8 value defaults to Frankfurt
        assert_eq!(Region::from(255u8), Region::Frankfurt);
    }

    #[test]
    fn test_validator_count() {
        // In stub mode, count is 0
        // With real data, count matches loaded validators
        let count = validator_count();
        if is_stub() {
            assert_eq!(count, 0);
        }
        // If not stub, count should be > 0
    }
}
