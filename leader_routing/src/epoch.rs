//! Epoch metadata and time-to-slot calculation.
//!
//! Uses rkyv for zero-copy access to embedded epoch data generated at compile time.
//!
//! ## Data Flow
//! 1. Python script fetches Solana epoch info (start_time, slot_duration, slot range)
//! 2. build.rs serializes metadata to `epoch.rkyv` using rkyv
//! 3. Runtime accesses via zero-copy `archived_root` (no deserialization cost)
//!
//! ## Slot Calculation
//! - Slot = start_slot + floor((now_ms - start_time_ms) / 400ms)
//! - Result is clamped to [start_slot, end_slot] range
//! - Before epoch start: returns start_slot (safe fallback)
//! - After epoch end: returns end_slot (graceful degradation)

use rkyv::{Archive, Deserialize, Serialize};

/// Aligned wrapper for embedded epoch data.
///
/// rkyv requires the buffer to be aligned to the largest field alignment
/// in the archived struct. EpochMetadata contains u64 fields, which require
/// 8-byte alignment. Without this wrapper, include_bytes! provides only
/// 1-byte alignment, causing rkyv::archived_root to panic.
///
/// See: https://rkyv.org/zero-copy-deserialization.html
#[repr(C, align(8))]
struct Aligned<const N: usize>([u8; N]);

/// Epoch data with proper alignment for rkyv.
const EPOCH_DATA_ALIGNED: &Aligned<{ include_bytes!(concat!(env!("OUT_DIR"), "/epoch.rkyv")).len() }> =
    &Aligned(*include_bytes!(concat!(env!("OUT_DIR"), "/epoch.rkyv")));

/// Get the aligned epoch data bytes.
fn epoch_data() -> &'static [u8] {
    &EPOCH_DATA_ALIGNED.0
}

/// Epoch metadata structure.
#[derive(Archive, Deserialize, Serialize, Debug, Clone)]
pub struct EpochMetadata {
    pub start_time_ms: u64,
    pub slot_duration_ms: u64,
    pub start_slot: u64,
    pub end_slot: u64,
}

/// Get archived epoch metadata (zero-copy).
///
/// # Safety
/// The data is embedded at compile time and validated by rkyv.
pub fn epoch_metadata() -> &'static ArchivedEpochMetadata {
    // SAFETY: Data is generated by build.rs, aligned, and validated at compile time
    unsafe { rkyv::archived_root::<EpochMetadata>(epoch_data()) }
}

/// Calculate the current slot based on system time.
///
/// Uses the epoch metadata to determine the slot for the current time.
/// Clamps the result to the epoch boundaries.
pub fn current_slot() -> u64 {
    let now_ms = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("System time before UNIX epoch")
        .as_millis() as u64;

    slot_for_time(now_ms)
}

/// Calculate slot for a given timestamp (deterministic, for testing).
///
/// # Arguments
/// * `timestamp_ms` - Unix timestamp in milliseconds
///
/// # Returns
/// The slot number for the given time, clamped to epoch boundaries.
pub fn slot_for_time(timestamp_ms: u64) -> u64 {
    let meta = epoch_metadata();

    // Before epoch start
    if timestamp_ms < meta.start_time_ms {
        return meta.start_slot;
    }

    // Calculate offset from epoch start
    let elapsed_ms = timestamp_ms - meta.start_time_ms;
    let slot_offset = elapsed_ms / meta.slot_duration_ms;

    // Clamp to epoch boundaries
    let slot = meta.start_slot + slot_offset;
    slot.min(meta.end_slot)
}

/// Get the slot offset within the current epoch (0-based index into leader schedule).
pub fn slot_offset(slot: u64) -> u64 {
    let meta = epoch_metadata();
    slot.saturating_sub(meta.start_slot)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_epoch_metadata_loads() {
        let meta = epoch_metadata();
        // Just verify it loads without panic
        assert!(meta.slot_duration_ms > 0);
    }

    #[test]
    fn test_slot_for_time_before_epoch() {
        let meta = epoch_metadata();
        // Time before epoch should return start_slot
        let before = meta.start_time_ms.saturating_sub(1000);
        assert_eq!(slot_for_time(before), meta.start_slot);
    }

    #[test]
    fn test_slot_for_time_at_start() {
        let meta = epoch_metadata();
        assert_eq!(slot_for_time(meta.start_time_ms), meta.start_slot);
    }

    #[test]
    fn test_slot_for_time_clamped() {
        let meta = epoch_metadata();
        // Far future should clamp to end_slot
        let far_future = meta.start_time_ms + (meta.end_slot - meta.start_slot + 1000) * 400;
        assert_eq!(slot_for_time(far_future), meta.end_slot);
    }

    #[test]
    fn test_slot_offset() {
        let meta = epoch_metadata();
        assert_eq!(slot_offset(meta.start_slot), 0);
        assert_eq!(slot_offset(meta.start_slot + 100), 100);
    }

    #[test]
    fn test_slot_for_time_one_slot_after_start() {
        let meta = epoch_metadata();
        // One slot duration after start should return start_slot + 1
        let one_slot_later = meta.start_time_ms + meta.slot_duration_ms;
        assert_eq!(slot_for_time(one_slot_later), meta.start_slot + 1);
    }

    #[test]
    fn test_slot_for_time_partial_slot() {
        let meta = epoch_metadata();
        // Halfway through first slot should still be start_slot (floor division)
        let halfway = meta.start_time_ms + (meta.slot_duration_ms / 2);
        assert_eq!(slot_for_time(halfway), meta.start_slot);
    }

    #[test]
    fn test_slot_offset_before_epoch() {
        let meta = epoch_metadata();
        // Slot before start_slot should clamp to 0 (saturating_sub)
        if meta.start_slot > 0 {
            assert_eq!(slot_offset(meta.start_slot - 1), 0);
        }
    }
}
