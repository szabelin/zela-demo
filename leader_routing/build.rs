//! Build script for leader_routing.
//!
//! ## What This Generates
//! - `phf_geo.rs`: PHF map for O(1) validator -> region lookup
//!
//! ## Prerequisites
//! Run this Python script before building:
//! - `python scripts/precompute_geo.py` -> `data/leader_geo.json`
//!
//! Without this file, stub data is generated.

use std::collections::HashMap;
use std::io::Write;
use std::{env, fs, path::Path};

fn main() {
    println!("cargo:rerun-if-changed=data/leader_geo.json");

    let geo_path = "data/leader_geo.json";

    if !Path::new(geo_path).exists() {
        // CI mode: fail if stub data would be used
        if env::var("LEADER_ROUTING_REQUIRE_DATA").is_ok() {
            eprintln!("=== BUILD FAILED: Missing data file ===");
            eprintln!("  - data/leader_geo.json is missing");
            eprintln!();
            eprintln!("To fix:");
            eprintln!("  1. pip install requests base58");
            eprintln!("  2. python scripts/precompute_geo.py");
            eprintln!("  3. cargo build");
            panic!("Data file required in CI mode");
        }

        create_stub_files();
        return;
    }

    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = Path::new(&out_dir);

    // Process leader_geo.json
    let geo_json = fs::read_to_string(geo_path)
        .expect("Failed to read leader_geo.json");
    let geo_map: HashMap<String, String> = serde_json::from_str(&geo_json)
        .expect("Failed to parse leader_geo.json");

    generate_validator_to_region_phf(&geo_map, out_path);
}

/// Map region name to u8 code for compact storage.
fn region_to_u8(region: &str) -> u8 {
    match region {
        "Frankfurt" => 0,
        "Dubai" => 1,
        "NewYork" => 2,
        "Tokyo" => 3,
        _ => 4, // Unknown
    }
}

fn generate_validator_to_region_phf(geo_map: &HashMap<String, String>, out_path: &Path) {
    let mut entries = Vec::new();
    let mut valid_entries = 0;
    let mut skipped_entries = 0;

    for (pubkey_b58, region) in geo_map {
        // Decode base58 pubkey to bytes
        let pubkey_bytes = match bs58::decode(pubkey_b58).into_vec() {
            Ok(bytes) if bytes.len() == 32 => bytes,
            Ok(bytes) => {
                eprintln!(
                    "Warning: skipping pubkey with invalid length: {} (got {})",
                    &pubkey_b58[..8.min(pubkey_b58.len())],
                    bytes.len()
                );
                skipped_entries += 1;
                continue;
            }
            Err(e) => {
                eprintln!(
                    "Warning: failed to decode pubkey {}: {}",
                    &pubkey_b58[..8.min(pubkey_b58.len())],
                    e
                );
                skipped_entries += 1;
                continue;
            }
        };

        // Format key as [u8; 32] literal
        let key_literal = format!(
            "[{}]",
            pubkey_bytes
                .iter()
                .map(|b| format!("0x{:02x}", b))
                .collect::<Vec<_>>()
                .join(", ")
        );

        // Region as u8
        let region_code = region_to_u8(region);

        entries.push((key_literal, region_code));
        valid_entries += 1;
    }

    let phf_path = out_path.join("phf_geo.rs");
    let mut file = fs::File::create(&phf_path).expect("Failed to create phf_geo.rs");

    writeln!(file, "/// Auto-generated PHF map: validator pubkey -> region").unwrap();
    writeln!(file, "/// Generated by build.rs from data/leader_geo.json").unwrap();
    writeln!(file, "/// Valid entries: {}, Skipped: {}", valid_entries, skipped_entries).unwrap();

    // Use phf_map! macro directly for [u8; 32] keys
    writeln!(file, "pub static VALIDATOR_TO_REGION: phf::Map<[u8; 32], u8> = phf::phf_map! {{").unwrap();
    for (key, value) in &entries {
        writeln!(file, "    {} => {}u8,", key, value).unwrap();
    }
    writeln!(file, "}};").unwrap();

    println!(
        "cargo:warning=Generated geo PHF map: {} validators",
        valid_entries
    );
}

/// Create stub files for initial compilation without data files.
fn create_stub_files() {
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = Path::new(&out_dir);

    // Stub PHF geo map (empty)
    let geo_path = out_path.join("phf_geo.rs");
    let mut geo_file = fs::File::create(&geo_path).expect("Failed to create phf_geo.rs");
    writeln!(geo_file, "/// STUB: Run python scripts/precompute_geo.py to generate real data")
        .expect("Failed to write");
    writeln!(
        geo_file,
        "pub static VALIDATOR_TO_REGION: phf::Map<[u8; 32], u8> = phf::phf_map! {{}};"
    )
    .expect("Failed to write");

    println!("cargo:warning=Using stub data - run: python scripts/precompute_geo.py");
}
